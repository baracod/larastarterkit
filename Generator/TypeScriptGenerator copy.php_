<?php

namespace App\Generator;

use App\Generator\IA\LanguageGenerator;
use App\Generator\ModuleGenerator;
use App\Generator\Utils\ConsoleTrait;
use App\Generator\Utils\GeneratorTrait;
use DeepSeek\DeepSeekClient;
use DeepSeek\Enums\Models;
use Gemini;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;
use OpenAI;

use function Laravel\Prompts\progress;
use function Laravel\Prompts\spin;

class TypeScriptGenerator
{
    use GeneratorTrait;
    use ConsoleTrait;
    protected string $tableName;
    protected string $modelName;
    protected string $typesFilePath;
    protected string $apiDirectory;
    protected string $moduleName;
    protected string $moduleNameLower;
    protected string $baseUrl;
    protected $module;

    public function __construct(string $tableName, string $modelName, $moduleName)
    {
        $this->tableName = $tableName;
        $this->modelName = $modelName;
        $this->moduleName = $moduleName;

        $this->module = new ModuleGenerator($moduleName);
        $this->typesFilePath = $this->module->getPath('resources/ts/types/entities.d.ts');
        $this->apiDirectory = $this->module->getPath("resources/ts/api/");
        $this->baseUrl = strtolower($moduleName . '/' . str::smartPlural($modelName));
        $this->moduleNameLower = strtolower($moduleName);
    }

    function extractJsonFromString(string $input): ?string
    {
        // Recherche du premier `{` et `}` pour détecter un objet JSON
        $startObject = strpos($input, '{');
        $endObject = strrpos($input, '}');

        // Recherche du premier `[` et `]` pour détecter un tableau JSON
        $startArray = strpos($input, '[');
        $endArray = strrpos($input, ']');

        // Déterminer quelle structure JSON (objet ou tableau) est la première dans le texte
        if ($startObject !== false && ($startArray === false || $startObject < $startArray)) {
            // Cas d'un objet JSON `{...}`
            $jsonString = substr($input, $startObject, ($endObject - $startObject + 1));
        } elseif ($startArray !== false) {
            // Cas d'un tableau JSON `[...]`
            $jsonString = substr($input, $startArray, ($endArray - $startArray + 1));
        } else {
            return null; // Aucun JSON trouvé
        }

        // Vérification si c'est un JSON valide
        json_decode($jsonString);
        if (json_last_error() === JSON_ERROR_NONE) {
            return $jsonString;
        }

        return null; // Aucun JSON valide trouvé
    }


    /**
     * Génère ou met à jour les fichiers TypeScript.
     */
    public function generate()
    {
        // try {
        if (!DB::getSchemaBuilder()->hasTable($this->tableName)) {
            throw new \Exception("La table `{$this->tableName}` n'existe pas.");
        }

        $columns = $this->extractColumns();
        $relations = $this->detectRelations();
        $typeDefinition = $this->mapColumnsToTypeScript($columns, $relations);

        $this->generateAddOrEditComponent();

        $this->updateTypeDefinitionFile($typeDefinition);
        $this->generateApiServiceFile($relations);
        $this->generateVuePageFile(); // generate index.vue
        $this->updateMenuItems('add');
        $this->generateAddOrEditComponent();
        $this->generateLangFileByAI();

        return true;
        // } catch (\Throwable $th) {
        //     $this->consoleWriteError('Erreur de generation du fichier TypeScript : ' . $th->getMessage());
        //     return false;
        // }
    }

    public function generateLangFileByAI2()
    {

        // try {
        $columns = $this->extractColumns();
        $relations = $this->detectRelations();
        $typeDefinition = $this->mapColumnsToTypeScript($columns, $relations);

        $formattedColumns = [];
        foreach ($columns as $column) {
            $formattedColumns[] = [
                $column->Field => 'valeur à completer dans la langue',
            ];
        }
        $formattedColumns = json_encode($formattedColumns, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n";


        //appel de openAI pour générer le code
        $this->consoleWriteMessage("Génération du code TypeScript pour le modèle '$this->modelName'...");

        $this->consoleWriteMessage("Appel de l'API OpenAI pour générer le code TypeScript...");

        $responseModel = '{
                "fr": {
                        "id": "value",
                        "name": "value"
                },
                "en": {
                        "id": "value",
                        "name": "value"
                }
            }';
        $prompte_1 = "Je vais te fournir les clés d'un fichier de langue pour une application web. Génère un fichier JSON avec les traductions en français et anglais, adaptées à une interface utilisateur et compréhensibles par des humains.
                            La clé principale est : $formattedColumns.
                            L'entité concernée est $this->modelName du module $this->moduleName.
                            Les noms des champs doivent être traduits en tenant compte du contexte du module.
                            Ajoute les clés suivantes dans entityInfo:
                            menu_title : Nom de l’entité traduit en français et anglais, au pluriel.
                            menu_description : Nom de l’entité traduit en français et anglais, au pluriel.
                            title_plural : c'est le titre au pluriel  à afficher dans index.
                            title : Nom de l’entité traduit en français et anglais, au singulier ex : User, Utilisateur.
                            Réponse attendue : Un JSON brut contenant uniquement les traductions, toute les clé doivent être en camel-case sans explication ni formatage supplémentaire.
                           
                            model de la réponse : $responseModel,
                            il faut que le caractère de séparation entre les mots soit en camelCase
                        ";

        $response = DeepSeekClient::build(env('DEEPSEEK_API_KEY'))
            ->query($prompte_1)
            ->run();

        File::put('bootstrap/cache/aiResponse.json', $response);
        $response = File::get('bootstrap/cache/aiResponse.json');
        $response = json_decode($response, true);
        dd($response);

        $response = $response['choices'];
        $response = $response[0]['message']['content'];
        $response = $this->extractJsonFromString($response);
        $arrayResponse = json_decode($response, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \Exception("Le JSON retourné par Deepseek IA n'est pas valide.");
        }


        foreach ($arrayResponse as $lang => $value) {
            $filePath = $this->module->getPath("resources/ts/locales/{$lang}.json");
            $directoryPath = $this->module->getPath("resources/ts/locales");
            if (!File::isDirectory($directoryPath)) {
                File::makeDirectory($directoryPath, 0755, true);
            }
            File::ensureDirectoryExists(dirname($filePath));
            $langFile = '';
            if (File::exists($filePath)) {
                $langFile = File::get($filePath);
            }

            $lang = json_decode($langFile, true);
            $entity =  Str::camel($this->modelName);

            $formattedLang =  [];
            $formattedLang  = $value['entityInfo'];
            unset($value['entityInfo']);
            $formattedLang['field'] = $value;

            if (isset($lang[strtolower($this->modelName)])) {
                echo ("Existe deja");
            } else {
                $lang[$entity] = $formattedLang;
            }

            // $fileName = Str::lower($this->modelName) . '.json';
            // $filePath = $this->module->getPath("resources/ts/lang/{$lang}/$fileName");
            File::ensureDirectoryExists(dirname($filePath));
            File::put($filePath, json_encode($lang, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE) . "\n");
        }
        return true;
        // } catch (\Throwable $th) {
        //     $this->consoleWriteError('Erreur de generation du fichier de langue par ia : ' . $th->getMessage());
        // }
    }

    /**
     * Génère (ou met à jour) les fichiers de langues <module>/resources/ts/locales/{lang}/{entity}.json
     * à partir des colonnes de la table et des traductions produites par DeepSeek.
     *
     * @param  bool  $preview  Si true, affiche la réponse JSON sans écrire sur disque.
     * @throws \RuntimeException  Quand le JSON retourné n’est pas valide.
     * @return bool
     */
    public function generateLangFileByAI(bool $preview = false): bool
    {
        // try {
        /* -----------------------------------------------------------------
         | 1. Extraction et préparation des clés à traduire
         *-----------------------------------------------------------------*/
        $columns = $this->extractColumns();
        if (empty($columns)) {
            $this->consoleWriteError('Aucune colonne détectée pour ce modèle.');
            return false;
        }

        $fieldKeys = array_map(fn($c) => $c->Field, $columns);
        $fieldKeysJson = json_encode($fieldKeys, JSON_UNESCAPED_SLASHES);


        $gen = new LanguageGenerator();               // tout par défaut




        /* -----------------------------------------------------------------
            | 2. Construction d’un prompt clair, stable et contextuel
            *-----------------------------------------------------------------*/
        // $prompt = <<<PROMPT
        //     Tu es un assistant IA spécialisé dans l’UX multilingue.
        //     Génère un JSON bilingue (fr/en) pour l’entité "{$this->modelName}" (module "{$this->moduleName}").

        //     Contraintes :
        //     • Les clés JSON doivent être en camelCase.
        //     • Ne renvoie que le JSON (aucun texte autour).
        //     • Structure attendue :
        //         {
        //         "fr": {
        //             "entityInfo": {
        //             "menuTitle": "...",
        //             "menuDescription": "...",
        //             "title": "...",
        //             "titlePlural": "..."
        //             },
        //             "field": {
        //             <cléChamp1>: "...",
        //             <cléChamp2>: "..."
        //             }
        //         },
        //         "en": { ... identique ... }
        //         }

        //     Liste des champs : {$fieldKeysJson}
        // PROMPT;

        /* -----------------------------------------------------------------
         | 3. Appel DeepSeek – modèle Chat, température modérée
         *-----------------------------------------------------------------*/
        // $rawResponse = DeepSeekClient::build(env('DEEPSEEK_API_KEY'))
        //     ->withModel(Models::CHAT->value)   // ou CODER si tu génères du code
        //     ->setTemperature(0.5)              // 0.5 = traductions cohérentes
        //     ->query($prompt)
        //     ->run();                           // Renvoie déjà la chaîne JSON

        /* -----------------------------------------------------------------
         | 4. Décodage robuste
         *-----------------------------------------------------------------*/
        $translations = spin(
            message: 'Chargement des fichiers de langues...',
            callback: fn() => $gen->generateBilingualJson(
                entity: $this->modelName,
                module: $this->moduleName,
                fields: $fieldKeys,                           // liste de champs
                asArray: true                            // true = array PHP
            )
        );
        // $rawResponse  = File::get('bootstrap/cache/aiResponse.json');
        // dd($rawResponse);
        // $translations = $this->extractJsonFromString($rawResponse);

        // if ($preview) {
        //     // Mode simulation : on n’écrit rien, on affiche
        //     $this->consoleWriteComment(
        //         json_encode($translations, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE)
        //     );
        //     return true;
        // }

        // $translations =  $this->extractJsonFromString($translations);
        // $translations =  $this->safeJsonDecode($translations, true);


        /* -----------------------------------------------------------------
         | 5. Écriture / mise à jour par langue et par entité
         *-----------------------------------------------------------------*/
        foreach ($translations as $lang => $payload) {

            $entityKey = Str::camel($this->modelName);
            $basePath  = $this->module->getPath("resources/ts/locales");
            $filePath  = "{$basePath}/{$lang}.json";

            File::ensureDirectoryExists($basePath);
            $existing  = File::exists($filePath)
                ? $this->safeJsonDecode(File::get($filePath))
                : [];

            // On écrase ou ajoute l’entité sans toucher aux autres
            $existing[$entityKey] = $payload;
            // $existing = $this->flattenLangStructure($existing);


            File::put(
                $filePath,
                json_encode($existing, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE) . PHP_EOL
            );
        }

        $this->consoleWriteSuccess('Fichiers de langue générés avec succès.');
        return true;
        // } catch (\Throwable $e) {
        //     // Log + retour propre
        //     // Log::error('AI Lang Generation', ['error' => $e->getMessage()]);
        //     $this->consoleWriteError('Erreur IA : ' . $e->getMessage());
        //     return false;
        // }
    }

    public function generateLangFileByAiGemma($prompt)
    {


        $key = getenv('GEMINI_API_KEY');
        $client = Gemini::client($key);
        $response = $client->generativeModel('gemma-3-27b-it')
            ->generateContent($prompt);
        $response =  $response->candidates[0]->content->parts[0]->text;
        return $response;
    }

    private function flattenLangStructure(array $translations): array
    {
        foreach ($translations as $entity => &$content) {
            if (isset($content['entityInfo'])) {
                $content = array_merge($content['entityInfo'], [
                    'field' => $content['field'] ?? []
                ]);
            }
        }
        unset($content);
        return $translations;
    }


    /* -------------------------------------------------------------------------
    | Méthode utilitaire : décodage JSON sécurisé
    *-------------------------------------------------------------------------*/
    private function safeJsonDecode(string $json): array
    {
        $data = json_decode($json, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \RuntimeException(
                'JSON invalide retourné par DeepSeek : ' . json_last_error_msg()
            );
        }
        return $data;
    }



    /**
     * Manipule le fichier `menuItems.ts` pour ajouter, modifier ou supprimer un élément du menu.
     *
     * @param string $action ('add', 'update', 'delete')
     */
    private function updateMenuItems(string $action)
    {
        $filePath = $this->module->getPath("resources/ts/menuItems.json");

        // Vérifier si le fichier existe, sinon le créer avec une structure TypeScript vide
        if (!File::exists($filePath)) {
            File::put($filePath, "[\n]");
        }

        // Lire le contenu actuel
        $fileContent = File::get($filePath);

        // Définir les propriétés du nouvel item  
        $routeName = Str::smartPlural($this->modelName);
        $routeName = strtolower("{$this->moduleName}-{$routeName}");
        $title = Str::ucfirst($this->modelName);
        $newMenuItem = [
            'title' => $this->moduleName . '.' . Str::camel($title) . '.menuTitle',
            'to' => ['name' => $routeName],
            'icon' => ['icon' => 'bx-file-blank'],
            'action' => 'access',
            'subject' => $this->tableName,
        ];

        $menuItems = json_decode($fileContent, true);

        //verifier si l'item existe déjà
        $itemExists = collect($menuItems)->contains(function ($item) use ($newMenuItem) {
            return $item['title'] === $newMenuItem['title'];
        });

        if ($itemExists) {
            $this->consoleWriteError("L'élément du menu '$title' existe déjà dans module '$this->moduleName'.");
            return;
        }


        // Ajouter le nouvel item à la fin du tableau
        array_push($menuItems, $newMenuItem);

        // Convertir le tableau en JSON et le réécrire dans le fichier
        $updatedContent = json_encode($menuItems, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . "\n";

        // Réécrire uniquement la partie modifiée du fichier sans écraser les autres données
        File::put($filePath, $updatedContent);
    }

    /**
     * Génère un fichier Vue (`pages/[model].vue`) en utilisant un stub et Vuetify en CamelCase.
     */
    public function generateVuePageFile()
    {
        $pageDirectoryName = strtolower(Str::smartPlural($this->modelName));
        $filePath = $this->module->getPath("resources/ts/pages/{$pageDirectoryName}/index.vue");


        // Charger le stub du fichier Vue
        $stubPath = base_path('/stubs/entity-generator/frontend/index.vue.stub');
        if (!File::exists($stubPath)) {
            throw new \Exception("Le fichier stub `/stubs/entity-generator/frontend/index.vue.stub` est introuvable.");
        }

        $stubContent = File::get($stubPath);

        // Générer les en-têtes pour `VDataTable`
        $columns = DB::select("SHOW COLUMNS FROM `{$this->tableName}`");
        $customDisplayColumn = '';


        $headers = [];
        foreach ($columns as $column) {
            if ($column->Type == 'tinyint(1)') {
                $customDisplayColumn .= $this->customerDisplayColumn($column);
            }

            if ($column->Field === 'created_at')
                $column = null;
            else if ($column->Field === 'updated_at')
                $column = null;
            else if ($column->Field === 'deleted_at')
                $column = null;
            else if ($column->Field === 'updated_by_id')
                $column = null;
            else if ($column->Field === 'deleted_by_id')
                $column = null;
            else if ($column->Field === 'created_by_id')
                $column = null;
            else if ($column->Field === 'id')
                $column = null;

            //créer un tableau d'en-têtes pour VDataTable
            if (!empty($column)) {
                $headers[] = "{ title: '" . Str::ucfirst($column->Field) . "', key: '{$column->Field}' }";
                // verifier si une colonne a besoin d'un affichage personnalisé

            }
        }

        $headersString = implode(",\n  ", $headers) . ',';


        // Remplacer les valeurs dynamiques dans le stub
        $vueCode = str_replace(
            [
                '{{ modelName }}',
                '{{ headers }}',
                '{{ moduleName }}',
                '{{ permissionsSubject }}',
                '{{ customDisplayColumn }}',
                '{{ moduleName }}'
            ],
            [
                $this->modelName,
                $headersString,
                $this->moduleName,
                $this->tableName,
                $customDisplayColumn,
                $this->modelName
            ],
            $stubContent
        );

        // Créer le fichier Vue avec les bonnes valeurs
        File::ensureDirectoryExists(dirname($filePath));
        File::put($filePath, $vueCode);
    }

    private function customerDisplayColumn($column)
    {
        // Vérifier si la colonne nécessite un affichage personnalisé
        // si c'est un booléen (tinyint(1))
        if ($column->Type === 'tinyint(1)') {
            $component = '
            <template #item.{{ field }}="{ item }">
                <VChip
                    :color="item.{{ field }} ? \'success\' : \'error\'"
                    size="small"
                >
                    {{ item.{{ field }} ? t(\'action.yes\') : t(\'action.no\') }}
                </VChip>
            </template>

            ';

            $component = str_replace('{{ field }}', $column->Field, $component);
            return $component;
        }
    }

    /**
     * Extrait les colonnes de la table et vérifie si elles sont NULLABLE.
     */
    private function extractColumns(): array
    {
        return DB::select("SHOW COLUMNS FROM `{$this->tableName}`");
    }

    /**
     * Détecte les relations `hasMany` et `belongsTo` basées sur les clés étrangères.
     */
    private function detectRelations(): array
    {
        $relations = [
            'hasMany' => [],
            'belongsTo' => []
        ];

        // Détection des `belongsTo`
        $foreignKeys = DB::select(
            "SELECT COLUMN_NAME, REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
            FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE 
            WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ? AND REFERENCED_TABLE_NAME IS NOT NULL",
            [env('DB_DATABASE'), $this->tableName]
        );


        foreach ($foreignKeys as $foreignKey) {
            $relatedModel = $this->tableNameToModelName($foreignKey->REFERENCED_TABLE_NAME);
            $relations['belongsTo'][] = [
                'model' => $relatedModel,
                'field' => $foreignKey->COLUMN_NAME,
                'table' => $foreignKey->REFERENCED_TABLE_NAME
            ];
        }

        // Détection des `hasMany`
        $referencedKeys = DB::select(
            "SELECT TABLE_NAME, COLUMN_NAME
            FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE 
            WHERE TABLE_SCHEMA = ? AND REFERENCED_TABLE_NAME = ?",
            [env('DB_DATABASE'), $this->tableName]
        );

        foreach ($referencedKeys as $referencedKey) {
            $relatedModel = $this->tableNameToModelName($referencedKey->TABLE_NAME);
            $relations['hasMany'][] = [
                'model' => $relatedModel,
                'field' => $referencedKey->COLUMN_NAME
            ];
        }

        return $relations;
    }

    /**
     * Convertit les colonnes en types TypeScript (avec gestion des relations et nullable).
     */
    private function mapColumnsToTypeScript(array $columns, array $relations): string
    {
        $types = [];

        foreach ($columns as $column) {
            $type = $this->getTypeScriptType($column->Type, $column->Null === 'YES');
            $nullable = $column->Null === 'YES' ? '?' : '';
            $types[] = "  {$column->Field}$nullable: $type;";
        }

        // Ajout des relations `hasMany`
        foreach ($relations['hasMany'] as $relation) {
            $types[] = "  {$relation['model']}?: I{$relation['model']}[];";
        }

        // Ajout des relations `belongsTo`
        foreach ($relations['belongsTo'] as $relation) {
            $types[] = "  {$relation['model']}?: I{$relation['model']};";
        }

        $formattedTypes = implode("\n", $types);

        return <<<EOD
            export interface I{$this->modelName} {
                $formattedTypes
            }
            EOD;
    }

    /**
     * Détermine le type TypeScript d'une colonne MySQL (avec gestion des nullable).
     */
    private function getTypeScriptType(string $dbType, bool $isNullable = false): string
    {
        $tsType = match (true) {
            str_contains($dbType, 'int') => 'number',
            str_contains($dbType, 'float') => 'number',
            str_contains($dbType, 'double') => 'number',
            str_contains($dbType, 'decimal') => 'number',
            str_contains($dbType, 'char') => 'string',
            str_contains($dbType, 'text') => 'string',
            str_contains($dbType, 'date') => 'string',
            str_contains($dbType, 'time') => 'string',
            str_contains($dbType, 'json') => 'any',
            default => 'string',
        };

        return $isNullable ? "$tsType | null" : $tsType;
    }

    /**
     * Met à jour le fichier `types.d.ts` avec les nouvelles interfaces.
     */
    private function updateTypeDefinitionFile(string $newTypeDefinition)
    {
        // Vérifier si le fichier existe
        if (!File::exists($this->typesFilePath)) {
            File::put($this->typesFilePath, $newTypeDefinition);
            return;
        }

        $existingContent = File::get($this->typesFilePath);

        // Vérifier si l'interface existe déjà
        if (preg_match("/export interface I{$this->modelName} \{.*?\}/s", $existingContent)) {
            // Supprimer l'ancienne définition
            $existingContent = preg_replace("/export interface I{$this->modelName} \{.*?\}/s", $newTypeDefinition, $existingContent);
        } else {
            // Ajouter la nouvelle définition à la fin
            $existingContent .= "\n\n" . $newTypeDefinition;
        }

        File::put($this->typesFilePath, trim($existingContent));
    }

    /**
     * Génère un fichier API TypeScript distinct pour chaque table (`api/{Model}.ts`).
     */
    private function generateApiServiceFile(array $relations)
    {
        $filePath = "{$this->apiDirectory}{$this->modelName}.ts";

        // Charger le stub du fichier API TypeScript
        $stubPath = base_path('/stubs/entity-generator/frontend/api.stub');
        if (!File::exists($stubPath)) {
            throw new \Exception("Le fichier stub `stubs/api.stub` est introuvable.");
        }

        $stubContent = File::get($stubPath);

        // Remplacer les valeurs dynamiques dans le stub
        $serviceCode = str_replace(
            ['{{ modelName }}', '{{ tableName }}', '{{ baseUrl }}'],
            [$this->modelName, $this->tableName, $this->baseUrl],
            $stubContent
        );

        // Créer le fichier API TypeScript avec les bonnes valeurs
        File::ensureDirectoryExists(dirname($filePath));
        File::put($filePath, $serviceCode);
    }


    /**
     * Génère le fichier `AddOrEdit.vue` dans `components/[model]/AddOrEdit.vue`.
     * Gère les relations `belongsTo` avec `VSelect` et sélectionne automatiquement `item-title`.
     */
    public function generateAddOrEditComponent()
    {
        $filePath = $this->module->getPath("resources/ts/components/{$this->moduleName}{$this->modelName}AddOrEdit.vue");

        // Charger le stub du fichier Vue
        $stubPath = base_path('stubs/entity-generator/frontend/addOrEdit.vue.stub');
        if (!File::exists($stubPath)) {
            throw new \Exception("Le fichier stub `stubs/entity-generator/frontend/addOrEdit.vue.stub` est introuvable.");
        }

        $stubContent = File::get($stubPath);

        // Générer les champs de formulaire Vuetify
        $columns = DB::select("SHOW COLUMNS FROM `{$this->tableName}`");
        $relations = $this->detectRelations();
        $fields = [];
        $defaultValues = [];
        $relationLists = [];
        $loadRelationLists = [];
        $imports = [];
        $entity = Str::camel($this->modelName);

        foreach ($columns as $column) {
            $fieldName = $column->Field;
            $label = Str::camel($fieldName);

            // Vérifier si le champ est une clé étrangère `belongsTo`
            $belongsToRelation = collect($relations['belongsTo'])->firstWhere('field', $fieldName);

            if ($belongsToRelation) {

                $moduleRelation = explode('_', $belongsToRelation['table'])[0] ?? '';
                $externalModuleRelation =  $moduleRelation == Str::lower($this->moduleName);

                $relatedTable = $belongsToRelation['table'];
                $relatedColumns = DB::select("SHOW COLUMNS FROM `{$relatedTable}`");

                // Trouver le champ qui suit `id`
                $itemTitleField = 'id';
                foreach ($relatedColumns as $index => $relatedColumn) {
                    if ($relatedColumn->Field === 'id' && isset($relatedColumns[$index + 1])) {
                        $itemTitleField = $relatedColumns[$index + 1]->Field;
                        break;
                    }
                }

                $relatedModel = $belongsToRelation['model'];
                $listVar = Str::camel($relatedModel) . "List";
                $fields[] = <<<EOD
                <CoreAutocomplete
                    v-model="form.{$fieldName}"
                    :label="t('{$this->moduleName}.{$entity}.field.{$label}')"
                    :items="{$listVar}"
                    item-value="id"
                    item-title="{$itemTitleField}"
                    required
                    :readonly="readonly"
                />
            EOD;

                if ($externalModuleRelation) {
                    // Ajout des imports des API associées
                    $imports[] = "import { {$relatedModel}API } from '@{$moduleRelation}/api/{$relatedModel}';";
                    $imports[] = "import type { I{$relatedModel} } from '@{$moduleRelation}/types/entities';";
                } else {
                    // Ajout des imports des API associées
                    $imports[] = "import { {$relatedModel}API } from '@{$this->moduleNameLower}/api/{$relatedModel}';";
                    $imports[] = "import type { I{$relatedModel} } from '@{$this->moduleNameLower}/types/entities';";
                }


                // Ajout du tableau pour stocker les valeurs
                $relationLists[] = "const {$listVar} = ref<I{$relatedModel}[]>([]);";
                // Chargement dynamique des données de la relation
                $loadRelationLists[] = "{$listVar}.value = await {$relatedModel}API.getAll();";
            } else {
                if ($fieldName !== 'id' && $fieldName !== 'created_at' && $fieldName !== 'updated_at') {
                    $component = $this->getVuetifyComponent($column->Type);
                    $fields[] = "<{$component} v-model=\"form.{$fieldName}\" :label=\"t('{$this->moduleName}.{$entity}.field.{$label}')\" required  :error-messages=\"errorMessage.{$fieldName}\" :readonly=\"readonly\"/>";
                }
            }

            $defaultValues[] = "{$fieldName}: " . ($this->getDefaultValue($column->Type));
        }

        $fieldsString = implode("\n          ", $fields);
        $defaultValuesString = "{ " . implode(', ', $defaultValues) . " }";
        $importsString = implode("\n", array_unique($imports));
        $relationListsString = implode("\n", $relationLists);
        $loadRelationListsString = implode("\n  ", $loadRelationLists);

        // Remplacer les valeurs dynamiques dans le stub
        $vueCode = str_replace(
            [
                '{{ modelName }}',
                '{{ formFields }}',
                '{{ defaultValues }}',
                '{{ relationLists }}',
                '{{ loadRelationLists }}',
                '{{ imports }}',
                '{{ moduleName }}',
                '{{ modelNameCamelCase }}'
            ],
            [
                $this->modelName,
                $fieldsString,
                $defaultValuesString,
                $relationListsString,
                $loadRelationListsString,
                $importsString,
                str::ucfirst($this->moduleName),
                str::camel($this->modelName)
            ],
            $stubContent
        );


        dd($importsString);

        // Créer le fichier Vue avec les bonnes valeurs
        File::ensureDirectoryExists(dirname($filePath));
        File::put($filePath, $vueCode);
    }

    /**
     * Retourne une valeur par défaut en fonction du type SQL.
     */
    private function getDefaultValue(string $dbType): ?string
    {
        return match (true) {
            str_contains($dbType, 'bigint') => 'null',
            str_contains($dbType, 'int') => '0',
            str_contains($dbType, 'float') => '0.0',
            str_contains($dbType, 'double') => '0.0',
            str_contains($dbType, 'decimal') => '0.0',
            str_contains($dbType, 'char') => "''",
            str_contains($dbType, 'text') => "''",
            str_contains($dbType, 'date') => "''",
            str_contains($dbType, 'time') => "''",
            str_contains($dbType, 'json') => "'{}'",

            default => "''"
        };
    }

    /**
     * Retourne le composant Vuetify approprié en fonction du type SQL (en CamelCase).
     */
    private function getVuetifyComponent(string $dbType): string
    {
        return match (true) {
            str_contains($dbType, 'tinyint(1)') => 'VCheckbox',
            str_contains($dbType, 'int') => 'CoreTextField type="number"',
            str_contains($dbType, 'float') => 'CoreTextField type="number"',
            str_contains($dbType, 'double') => 'CoreTextField type="number"',
            str_contains($dbType, 'decimal') => 'CoreTextField type="number"',
            str_contains($dbType, 'char') => 'CoreTextField',
            str_contains($dbType, 'text') => 'CoreTextarea',
            str_contains($dbType, 'date') => 'VDatePicker',
            str_contains($dbType, 'timestamp') => 'VDatePicker',
            str_contains($dbType, 'time') => 'VTimePicker',
            str_contains($dbType, 'json') => 'VTextarea',
            default => 'VTextField',
        };
    }
}
